# Функции

Функцией называется фрагмент программного кода, который может многократно вызываться в программе.
Они могут иметь аргументы, передававаемые внутрь тела функции, и возвращать или не возвращать значение.

Так выглядит пример обьявления функции:
```c++
double
my_function(int foo, bool bar = 0)
{
  return 0.1;
}

```
Эта функция возвращает значение типа double, при вызове как аргументы ей передаются значения типа `int`, и `bool`.
В данном примере аргумент типа `bool` можно пропустить, так как указано значение по умолчанию.

Для возврата значения используется инструкция `return`, она может быть одна, может быть несколько, а если тип возвращаемого значения  `void`, то её можно вовсе опустить. Вызов этой инструкции завершает выполнение функции.

Функция должна быть объявлена перед её вызовом, чтобы компилятор не выдал ошибку, в противном случае допускается создание прототипа функции в начале программы, например вот так:
```c++
double
my_function(int foo, bool bar = 0);

```
Прототип обязательно должен содержать тип возвращаемого значения, имя функции и её аргументы.
После чего соответствующую прототипу функцию можно объявлять где угодно.

Может быть несколько прототипов функции с одним названием, но разными аргументами, и возвращаемым значением. Это называется перегрузкой функции.

Так же функция может вызывать саму себя, это явление называется *рекурсией*.

### Аргументы
Есть два механизма передачи значения в функцию: *по значению* и *через ссылку*

Ссылка - указывает на конкретный адрес памяти, и позволяет обращаться к нему, подобно указателю, но без необходимости разыменования при вызове.
При передаче параметра как ссылки в функцию, вместо самой ссылки будет обрабатываться переменная на которую указывает ссылка.
Тогда как при передаче по значению, все операции над локальными переменными не выходят за пределы самой функции, выделяется место в памяти для копии значения аргумента и все манипуляции внутри функции производятся с этой копией.

Но если передать в функцию указатель на переменную, то функция примет аргумент по значению, и при этом мы сможем модифицировать значение переменной за пределами функции. Чтобы передать адрес переменной как аргумент при вызове функции нужно поставить перед именем переменной символ `&`.
Например так:
```c++
void
my_function(int* foo);

int a = 1;
my_function(&a);

```
Чтобы функция возвращала ссылку на значение, символ `&` надо поставить перед именем функции в ёё обьявлении.

# Текстовые строки и динамические массивы
Текстовые строки могут быть как обьектами стандартного класса `string` так и массивом элементов типа `char` - символьным массивом или си-строкой.
Си-строка должна заканчиваться спецсимволом `\0`, означающим конец строки.

Примеры объявления строки как символьного массива:
```c++
char foo[10]; //простое объявление

char bar[10] = "Hello!"; // объявление вместе с инициализацией

char foobar[] {'H', 'e', 'l', 'l', 'o', '!', '\0'}; // последние два варианта эквивалентны
```
Если пропустить последний элемент можно столкнуться с ошибками при работе со строкой, так как программа не будет знать где заканчивается строка.

Функции для работы с си-строками находятся в заголовочном файле `<cstring>`

* `strcpy(a, b)`  копирует строку `b` в строку `a`
* `strcat(a, b)`  производит конкатенацию двух строк
* `strcmp(a, b)`  если строки равны возвращает `false`, иначе `true`

* `strchr(ch, a)`  возвращает указатель на первое вхождение символа `ch`
* `strstr(a, b)`   возвращает указатель на первое вхождение подстроки `b` в строке `a`

Так же существует ряд функций для перевода значений из строковго типа в численый

* `atoi(s)` строка  в `int`
* `atol(s)` строка в `long`
* `atof(s)` строка в `double`

Печатать строку можно перемещась по ней указателем и печатая символы один за другим вплоть до конца строки. Это одно из удобных свойств си-строки.

Двумерный массив типа `char` можно рассматривать как одномерный массив строк.
Пример:
```c++
char amen[]
{
    "If you have ghosts, you have everything",
    "You can say anything you want",
    "And you can do anything you want to do"
};
```

### Динамические массивы

На момент компилиции размер динамической переменной не известен, в отличие от автоматической.
Её обьявление происходит с помощью ключевого слова `new` и указания нужного типа переменной. Это ключевое слово возвращает указатель на начало выделенного блока памяти.
Память после обьявления динамических переменнных нужно освобождать вручную, с помощью "delete".

```c++
int *p;
p = new int(); // в скобочках указано присваемое переменной значение

//..

delete p; // после окончания работы с переменной убраем мусор из памяти

```

Объявление динамического массива происходит аналогично:
```c++
char *pa;
pa = new char [10]

//..

delete [] pa; // удаляем массив из памяти
```
Двумерный динамический массив:
```c++
size_t size;
char **ppa;

ppa = new char* [size];

//..

for (size_t i = 0; i < size; i++)
  delete [] ppa[i]; // удаляем все подмассивы из памяти
delete [] ppa; // удаляем массив из памяти
```
# Структуры и перечисления


