# Краткие конспекты лекций 

### Лекция 1
Объект - переменная класса 
Класс(грубо) - похожий на структуру пользовательский тип  
Классы хрянят указатели на функции или переменные 
 
Класс в своей структуре может иметь приватные и публичные объекты 
Публичные доступны для вызова с экземпляром класса, тогда как приватные доступны только при обращении к ним внутри своего класса. 
 
Объектно-ориентированное программирование основано на трех принципах:  
Инкапсуляция - скрытие внутренней структуры объекта за простым для понимания и использования интерфейсом. 
Наследование - возможность расширения существующей функциональности класса. 
Полиморфизм (многоликость) - возможность единым образом взаимодействовать с объектами разной внутренней структуры. 
 
Существует два типа программистов: 
Объект-базированные - те кто использует в своих программах готовые классы упакованные в библиотеки. Их подавляющее большинство.  
Объектно-ориентированные - те кто создает библиотеки которыми пользуются объект-ориентированные программисты. 

### Лекция 2
У каждого класса существует конструктор по умолчанию, не имеющий параметров, с нулевым количеством параметров - это особый метод класса который позволяет инициализировать поля класса начальными значениями 
При объявлении класса мы можем перегружать существующий конструктор, при этом конструктор по умолчанию устраняется, и чтобы у класса существовал конструктор без параметров необходимо объявить его вручную. 
Также класс может иметь деструктор - это другой особый метод класса который вызывается для уничтожения элементов класса, например динамических полей. 
 
При написании конструктора следует следить чтобы у них не стояло типа возвращаемого значения, Имя конструктора совпадало с именем класса а имя деструктора также должно совпадать с именем класса но ему должен предшествовать символ "~", иначе это будет не деструктор. 
 
Внутри класса существует ключевое слово "this", которое позоляет обращаться к полям и методам класса изнутри самого класса. 


### Лекция 3
Так же как и под переменные, под объекты можно динамически выделять память. 
Через указатель на объект можно получать доступ к его публичным методам и полям используя вместо оператора `.` оператор `->`. 
Ключевое слово `this` - это указатель неявно передаваемый каждому методу класса. 
  
Также можно создать указатель на поле класса используя следующий синтаксис: 
`type ClassName::*pointer`, где  
* `type` - тип указателя совпадающий с типом поля на которое будет ссылаться указатель;  
* `СlassName` - имя класса которому принадлежит поле;  
* `pointer` - имя указателя;  
    
Присвоение указателю адреса поля класса:     
`pointer = ClassName::field`, где  
* `pointer` - имя указателя;  
* `СlassName` - имя класса которому принадлежит поле;  
* `field` - имя поля на которое мы создаем указатель;  
  
Создание указтеля на метод класса: 
`type (ClassName::*pointer)(arg1_type arg1, ...)`, где  
* `type` - тип указателя совпадающий с типом значения возвращаемого методом на который будет ссылаться указатель;  
* `СlassName` - имя класса которому принадлежит метод;  
* `pointer` - имя указателя;  
* `arg1_type arg1, ...` - список аргументов нужного метода, так как они указаны в объявлении класса;  
    
Присвоение указателю адреса метода класса:     
`pointer = ClassName::method`, где  
* `pointer` - имя указателя;  
* `СlassName` - имя класса которому принадлежит поле;  
* `method` - имя метода на который мы создаем указатель;  
  
Существует вариант объявления дружественных к классу внешних функций и классов.  
Дружественная классу функция объявляется в теле класса с которум она будет "дружить" следующим образом      
`friend type function(arg1_type arg1, ...)`
Перед объявлением функции (без тела) в том виде как она объявлена извне класса пишется слово `friend`.  


### Лекция 4  
Поля класса должны быть разделены, на публичные и приватные - это инкапсуляция. 
При отсутствии явно определённых конструкторов будет использоваться конструктор по умолчанию. 
При явном объявлении любого конструктора, конструктор по умолчанию прекращает существование, и чтобы его использовать нужно объявить его явно, как конструктор без параметров 
Деструктор может быть только одним, и он не имеет параметров, но его можно переопределить. 


### Лекция 5
Конструктор копирования, позволяет пиботово скопировать объект одноименного класса 
При иницализации экземпляра класса объект-аргумент конструктора передается по ссылке, под копию освобождается память и происходит побитовое копирование объекта аргумента в экземпляр.


### Лекция 7
Оператор аналогичен обычной функции, за исключением того как он вызывается.  
Они бывают бинарными и унарными, которые, в свою очередь, разделяются на префиксные и постфиксные.  
Перегрузка оператора производится с помощью конструкции `operator X`, где X - символ перегружаемого оператора. 
  
Пример перегрузки бинарного оператора принимающего на вход два значения типа `pair<double, double>` и возвращающего `double` 
```
double 
operator + (const pair<double, double>& left, const pair<double, double>& right)  
{ 
    return left.first * right.first + left.second * right.second; 
} 
``` 
Можно заметить, что я передаю операнды по ссылке, так чтобы они не копировались в память при вызове функции. Так оператору передаются указатели на области памяти где лежат значения операндов. 
Но при таком вызове есть вероятность, случайно изменить исходные операнды, для предотвращения этого я пишу `const` перед аргументом, таким образом защитив его от изменения оператором. 
  
Когда операнды переопределённого оператора относятся к разным типам положение важно их, так, если определен оператор для объекта и числа(1), но не определён опреатор для числа и объекта, то при попытке вызова оператора(1) дла операндов число и объект будет ошибка. 
  
Пример перегрузки унарного оператора в префиксной форме 
``` 
pair<double, double> 
operator ++ (pair<double, double>& operand)  
{ 
    this->first = operand.first++; 
    this->second = operand.second++; 
    return *this; 
} 
``` 
Здесь я возвращаю `*this`, чтобы не выделять лишней памяти под объект и работать напрямую с операндом, имея взможность присвоить значение оператора. (на сколько знаю это де-факто стандартное ожидаемое поведение оператора) 
  
Это пример постфиксной формы того же оператора, отличается лишь добавлением второго операнда котрорый не влияет на конечный результат, но сообщает о префиксной форме оператора. 
```
pair<double, double> 
operator ++ (pair<double, double>& operand, int ghost)  
{ 
    this->first = operand.first++; 
    this->second = operand.second++; 
    return *this; 
} 
``` 
  
Оператор присваивания нельзя перегружать внешней функцией. Но можно перегружать например как метод класса. 


### Лекция 8
Классы могут наследовать друг друга, при этом наследник получит часть свойств родителя. 
Наследнику можно добавить новые свойства. 
Наследование может быть как одиночным, так и множественным, но это более сложный механизм. 
В зависимости от типа наследования свойства дочернего класса могут отличаться от свойств родителя, поэтому в описании дочернего класса следует описать иденификатор доступа. 
Это может быть `public`, `private`, `protected`. 
При использовании public-наследования уровень доступа к членам класса не меняется. 
При protected-наследовании все наследуемые члены становятся protected. 
При любом виде наследования приватные члены родителя не наследуются. 
Родительский класс сам может быть наследником другого класса. 
Виртуальной функцией называется функция не определённая в базовом классе явно. 
Явно виртуальная функция объявляется в базовом классе с использованием ключевого слова `virtual`, наследники могут свободно переопределять такую функцию. 
Если класс содержит хотя бы одну виртуальную функцию то он называется абстрактным. 


### Лекция 9
Для классов, функций и операторов можно указывать шаблоны: 
```
template <class T, ...> 
class ClassName { 
    ... 
}; 
  
template <class T, ...> 
T FunctionName (T arg1, ...) { 
    ... 
}; 
``` 
  
При вызове функции подходящей под определение шаблона будет сгенерирован её вариант использующий вместо обобщенных типов, типы требуемые при вызове функции, или инициализации экземпляра класса. 
Если существует функция одноименная шаблону и принимающая аналогичные параметры, она будет использована вместо шаблона. 
Шаблон перегружаем. 

### Лекция 10
Существует инструкция try внутри которой имеет смысл писать участки кода потенциально способные вызвать ошибку. Для обработки таких ошибок и исключения непредвиденного поведения программы, в try следует указывать условия при которых будет вызвана инструкция throw передающая некоторое значение блоку catch следующему за try 
Далее с помощью блока catch мы можем вывести сообщение об ошибке или произвести любые другие манипуляции. 
Для исключений тоже можно задавть исключения. 


### Лекция 11
Пространства имен это область видимости в рамках которой определены некоторые идентификаторы, имена функций, переменных, типов и т.д. 
Пространства имен могут использваться с целью избежать конфликта имен разных функций, позволяет разбить код на логические блоки. 
Директива `using` позволяет использовать все имена из некоторого просторанства имен без явного указания имени пространства имен перед некоторым идентификатором принадлежащим этому пространству имен. 
  
Для программ на С++ предусмотрен стандартный механизм передачи парметров в програму. 
`int argc` хранит количество парметров переданных программе. 
`char* argv[]` хранит указатель на начало массива хранящего все параметры переданные программе. Где парметром с индексом 0 является имя самой программы. 
  
При работе с файлами мы используем механизм потоков. 
Для открытия файла для записи следует использовать обьект типа `ofstream`. Используя конструктор объекта или с помощью метода `open()` мы можем задать расположение целевого файла в файловой системе относительно исполняемого файла. Это инициализирует поток хранящий содержимое открытого программой файла. Таким образом рабта с файлом сводится к работе с потоком. 
Для завершения работы с файлом и закрытия потока следует использовать метод `close()`.
Для чтения из файла используется объект типа `ifstream`, ему также можно передать расположение целевого фала в методе `open` или в конструкторе. Здесь также работа с файлом сводится к работе с потоком. Для чтения фиксированного количества строк из файла может использоваться метод `getline(buffer, len)`, где `buffer` - переменная в которую будет записано содержимое, `len` - размер буфера (максимальная длина строки). 


### Лекция 13
Итератор - это общий универсальный интерфейс позволяющий получить доступ к элементам любой коллекции из стандартной библиотеки C++. 

В Стандартной библиотеке с++ предусмотрено несколько видов контейнеров, каждый со своими особенностями:  
Vector – очень похож на обычный массив, так же как и массив хранится в непрерывной области памяти. Доступен отдельный метод позволяющий добавлять новый элемент за последним элементом `push_back()`.  
List - двусвязный список, хранит свои элементы в куче, каждый элемент содержит указатели на предыдущий и следующий элемент.  
Deque - двусторонняя очередь элементы к которому можно добавлять как перед началом, так и в конце, и аналогично вынимать.  Доступно обращение по индексу за O(1)-время.  
Set - упорядоченное множество уникальных элементов. При попытке добавить в него уже существующий элемент, ничего не произойдет. Для хранения повторяющихся элементов следует использовать `multiset`.  
Map – контейнер организующий структуру хранения вида "ключ - значение". Ключи уникальный.  
Multimap – аналогичен, за исключением того, что позволяет хранить значения с повторяющимися ключами.  
Pair - `struct { first, second }`  
  
Sort() - позволяет упорядочивать элементы используя заранее определённый предикат.   
Reverse() - обращает элементы контейнера задом наперёд.  

